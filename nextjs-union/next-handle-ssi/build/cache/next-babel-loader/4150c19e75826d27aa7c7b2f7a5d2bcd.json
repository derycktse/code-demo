{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar _assertThisInitialized = require(\"@babel/runtime/helpers/assertThisInitialized\");\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nexports.__esModule = true;\nexports[\"default\"] = void 0;\nvar _react = require(\"react\");\nvar isServer = false;\nvar _default = function _default() {\n  var mountedInstances = new Set();\n  var state;\n  function emitChange(component) {\n    state = component.props.reduceComponentsToState(_toConsumableArray(mountedInstances), component.props);\n    if (component.props.handleStateChange) {\n      component.props.handleStateChange(state);\n    }\n  }\n  return /*#__PURE__*/function (_react$Component) {\n    _inherits(_class, _react$Component);\n    var _super = _createSuper(_class);\n    function _class(props) {\n      var _this;\n      _classCallCheck(this, _class);\n      _this = _super.call(this, props);\n      if (isServer) {\n        mountedInstances.add(_assertThisInitialized(_this));\n        emitChange(_assertThisInitialized(_this));\n      }\n      return _this;\n    }\n    _createClass(_class, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        mountedInstances.add(this);\n        emitChange(this);\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate() {\n        emitChange(this);\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        mountedInstances[\"delete\"](this);\n        emitChange(this);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        return null;\n      }\n    }], [{\n      key: \"rewind\",\n      value:\n      // Used when server rendering\n      function rewind() {\n        var recordedState = state;\n        state = undefined;\n        mountedInstances.clear();\n        return recordedState;\n      }\n    }]);\n    return _class;\n  }(_react.Component);\n};\nexports[\"default\"] = _default;","map":{"version":3,"sources":["../../../next-server/lib/side-effect.tsx"],"names":["isServer","mountedInstances","Set","state","emitChange","component","props","reduceComponentsToState","handleStateChange","Component","recordedState","undefined","clear","constructor","add","componentDidMount","componentDidUpdate","componentWillUnmount","render"],"mappings":";;;;;;;;;;;;;AAAA,IAAA,MAAA,GAAA,OAAA,CAAA,OAAA,CAAA;AAEA,IAAMA,QAAQ,QAAd;eAae,S,WAAM;EACnB,IAAMC,gBAA0B,GAAG,IAAIC,GAAJ,EAAnC;EACA,IAAIC,KAAJ;EAEA,SAASC,UAAT,CAAoBC,SAApB,EAAiE;IAC/DF,KAAK,GAAGE,SAAS,CAACC,KAAVD,CAAgBE,uBAAhBF,oBACFJ,gBADEI,GAENA,SAAS,CAACC,KAFJD,CAARF;IAIA,IAAIE,SAAS,CAACC,KAAVD,CAAgBG,iBAApB,EAAuC;MACrCH,SAAS,CAACC,KAAVD,CAAgBG,iBAAhBH,CAAkCF,KAAlCE,CAAAA;IACD;EACF;EAED;IAAA;IAAA;IASEQ,gBAAYP,KAAD,EAAa;MAAA;MAAA;MACtB,0BAAMA,KAAN;MACA,IAAIN,QAAJ,EAAc;QACZC,gBAAgB,CAACa,GAAjBb,+BAAAA;QACAG,UAAU,+BAAVA;MACD;MACF;IAAA;IACDW;MAAAA;MAAAA,oCAAoB;QAClBd,gBAAgB,CAACa,GAAjBb,CAAqB,IAArBA,CAAAA;QACAG,UAAU,CAAC,IAAD,CAAVA;MACD;IACDY;MAAAA;MAAAA,qCAAqB;QACnBZ,UAAU,CAAC,IAAD,CAAVA;MACD;IACDa;MAAAA;MAAAA,uCAAuB;QACrBhB,gBAAgB,UAAhBA,CAAwB,IAAxBA,CAAAA;QACAG,UAAU,CAAC,IAAD,CAAVA;MACD;IAEDc;MAAAA;MAAAA,yBAAS;QACP,OAAO,IAAP;MACD;IA9BH;MAAA;MAAA;MACE;MACA,kBAAgB;QACd,IAAMR,aAAa,GAAGP,KAAtB;QACAA,KAAK,GAAGQ,SAARR;QACAF,gBAAgB,CAACW,KAAjBX,EAAAA;QACA,OAAOS,aAAP;MACD;IAEDG;IAAAA;EAAAA,EATmBJ,MAAAA,CAAAA,SAA2B;AAgCjD,C","sourcesContent":["import React, { Component } from 'react'\n\nconst isServer = typeof window === 'undefined'\n\ntype State = Array<React.ReactElement<any>> | undefined\n\ntype SideEffectProps = {\n  reduceComponentsToState: <T>(\n    components: Array<React.ReactElement<any>>,\n    props: T\n  ) => State\n  handleStateChange?: (state: State) => void\n  inAmpMode?: boolean\n}\n\nexport default () => {\n  const mountedInstances: Set<any> = new Set()\n  let state: State\n\n  function emitChange(component: React.Component<SideEffectProps>) {\n    state = component.props.reduceComponentsToState(\n      [...mountedInstances],\n      component.props\n    )\n    if (component.props.handleStateChange) {\n      component.props.handleStateChange(state)\n    }\n  }\n\n  return class extends Component<SideEffectProps> {\n    // Used when server rendering\n    static rewind() {\n      const recordedState = state\n      state = undefined\n      mountedInstances.clear()\n      return recordedState\n    }\n\n    constructor(props: any) {\n      super(props)\n      if (isServer) {\n        mountedInstances.add(this)\n        emitChange(this)\n      }\n    }\n    componentDidMount() {\n      mountedInstances.add(this)\n      emitChange(this)\n    }\n    componentDidUpdate() {\n      emitChange(this)\n    }\n    componentWillUnmount() {\n      mountedInstances.delete(this)\n      emitChange(this)\n    }\n\n    render() {\n      return null\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}